---
title: Разработка плагинов
description: Как создать свой плагин для MPFlow — entities, API, middleware, cron jobs, страница в админке
---

# Разработка плагинов

Плагины MPFlow расширяют систему: свои таблицы в БД, API-роуты, middleware для обогащения данных, фоновые задачи и страницы в админке. Таблицы для плагинов создаются автоматически — не нужно писать миграции.

## Как это работает

При старте сервера:

1. Собираются entities из всех плагинов
2. ORM инициализируется со всеми entities (core + plugins)
3. `SchemaGenerator.updateSchema({ safe: true })` создаёт недостающие таблицы и колонки
4. Загружаются services, routes, middleware и cron jobs

`safe: true` означает только аддитивные изменения — CREATE TABLE, ADD COLUMN. Без DROP.

## Структура плагина

```
admin/plugins/my-plugin/
├── plugin.ts                     # Определение плагина (точка входа)
└── src/
    ├── modules/
    │   └── my-module/
    │       ├── entities.ts       # MikroORM entities
    │       └── service.ts        # Бизнес-логика
    ├── routes/
    │   └── my-routes.ts          # Hono API-роуты
    ├── middleware/
    │   └── my-enrichment.ts      # Middleware для обогащения данных
    └── workflows/
        └── my-sync.ts            # Логика фоновых задач
```

## Пошагово: создаём плагин

### 1. Создать директорию

```bash
mkdir -p admin/plugins/my-plugin/src/modules/my-module
```

### 2. Определить entity

Создайте `src/modules/my-module/entities.ts`. Используйте декораторы MikroORM:

```typescript
import { Entity, PrimaryKey, Property, Index } from "@mikro-orm/core"
import { v4 } from "uuid"

@Entity({ tableName: "my_record" })
export class MyRecord {
  @PrimaryKey()
  id: string = v4()

  @Property()
  name!: string

  @Property({ nullable: true })
  description?: string

  @Property({ default: true })
  is_active: boolean = true

  @Property({ type: "jsonb", nullable: true })
  metadata?: Record<string, unknown>

  @Property({ defaultRaw: "now()" })
  created_at: Date = new Date()

  @Property({ defaultRaw: "now()", onUpdate: () => new Date() })
  updated_at: Date = new Date()
}
```

Таблица `my_record` будет создана автоматически при старте сервера.

Доступные типы: `string`, `number`, `boolean`, `Date`, `jsonb`, `text`, `numeric`, `bigint`. Модификаторы: `nullable`, `default`, `unique`, `index`.

### 3. Создать сервис

Создайте `src/modules/my-module/service.ts`:

```typescript
import type { EntityManager } from "@mikro-orm/core"
import { MyRecord } from "./entities.js"

export class MyRecordService {
  constructor(private em: EntityManager) {}

  async list(filters: Record<string, any> = {}) {
    return this.em.find(MyRecord, filters)
  }

  async get(id: string) {
    return this.em.findOneOrFail(MyRecord, { id })
  }

  async create(data: Partial<MyRecord>) {
    const record = this.em.create(MyRecord, data as any)
    await this.em.persistAndFlush(record)
    return record
  }

  async update(id: string, data: Partial<MyRecord>) {
    const record = await this.em.findOneOrFail(MyRecord, { id })
    this.em.assign(record, data)
    await this.em.flush()
    return record
  }

  async delete(id: string) {
    const record = await this.em.findOneOrFail(MyRecord, { id })
    await this.em.removeAndFlush(record)
  }
}
```

Сервис получает `EntityManager` — request-scoped, безопасен для параллельных запросов.

### 4. Создать API-роуты

Создайте `src/routes/my-routes.ts`:

```typescript
import { Hono } from "hono"
import { getUserId } from "../../../src/server/core/auth.js"
import { MyRecordService } from "../modules/my-module/service.js"

const routes = new Hono<{ Variables: Record<string, any> }>()

routes.get("/", async (c) => {
  const userId = getUserId(c)
  const service: MyRecordService = c.get("container").resolve("myRecordService")
  const items = await service.list()
  return c.json({ items })
})

routes.post("/", async (c) => {
  const userId = getUserId(c)
  const body = await c.req.json()
  const service: MyRecordService = c.get("container").resolve("myRecordService")
  const item = await service.create(body)
  return c.json({ item }, 201)
})

export default routes
```

Сервисы достаются из DI-контейнера через `c.get("container").resolve("serviceName")`.

### 5. Написать plugin.ts

Создайте `plugin.ts` — точку входа плагина:

```typescript
import { definePlugin } from "../../src/server/core/plugin-loader.js"
import { MyRecord } from "./src/modules/my-module/entities.js"
import { MyRecordService } from "./src/modules/my-module/service.js"
import myRoutes from "./src/routes/my-routes.js"
import { asClass, Lifetime } from "awilix"

export default definePlugin({
  name: "my-plugin",
  label: "My Plugin",
  description: "Описание вашего плагина",

  // Префиксы API — для контроля доступа (отключение плагина блокирует эти роуты)
  apiPrefixes: ["/api/my-records"],

  // MikroORM entities — таблицы создадутся автоматически
  entities: [MyRecord],

  // Сервисы в DI-контейнере (SCOPED = новый экземпляр на каждый запрос)
  services: {
    myRecordService: asClass(MyRecordService, { lifetime: Lifetime.SCOPED }),
  },

  // Hono роуты
  routes: (app, _container) => {
    app.route("/api/my-records", myRoutes)
  },

  // Пункты навигации в админке
  adminNav: [
    { path: "/my-plugin", label: "My Plugin" },
  ],
})
```

### 6. Зарегистрировать плагин

Добавьте плагин в `admin/mpflow.config.ts`:

```typescript
export default defineConfig({
  // ...
  plugins: [
    { resolve: "./plugins/ozon" },
    { resolve: "./plugins/my-plugin" },  // ← ваш плагин
  ],
})
```

И в `admin/src/server/index.ts` в массив `pluginPaths`:

```typescript
const pluginPaths = [
  { resolve: "./plugins/ozon" },
  { resolve: "./plugins/my-plugin" },
]
```

### 7. Запустить

```bash
cd admin
npm run dev
```

При старте в логах будет:

```
[mpflow] Collected N plugin entities
[mpflow] Applying auto-schema updates for plugin entities...
[plugin] Loading: my-plugin
[plugin] Loaded: my-plugin
```

## PluginDefinition — полный API

```typescript
interface PluginDefinition {
  name: string        // Уникальное имя (например, "my-plugin")
  label: string       // Отображаемое название в UI
  description?: string

  entities?: any[]    // MikroORM entity-классы (таблицы создаются автоматически)

  services?: Record<string, any>  // Awilix-регистрации для DI-контейнера

  routes?: (app: Hono, container: AwilixContainer) => void  // Hono роуты

  middleware?: Array<{
    path: string                    // URL-паттерн (например, "/api/catalog")
    method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "ALL"
    handler: (c: any, next: () => Promise<void>) => Promise<any>
  }>

  jobs?: Array<{
    name: string                    // Уникальное имя задачи
    schedule: string                // Cron-выражение (например, "*/30 * * * *")
    handler: (container: any) => Promise<void>
  }>

  adminNav?: Array<{
    path: string                    // Путь в SPA (например, "/my-plugin")
    label: string                   // Название в сайдбаре
  }>

  apiPrefixes?: string[]  // Для контроля доступа (при отключении плагина блокируются)
}
```

## Дополнительные возможности

### Middleware (обогащение данных)

Middleware позволяет обогащать ответы core API. Например, Ozon-плагин добавляет данные об остатках к ответу `/api/catalog`:

```typescript
export async function myEnrichment(c: any, next: () => Promise<void>) {
  await next() // Сначала выполняется основной обработчик

  // Обогащаем ответ
  const body = await c.res.json()
  body.extra_data = "enriched"
  c.res = new Response(JSON.stringify(body), {
    status: c.res.status,
    headers: c.res.headers,
  })
}
```

### Cron jobs (фоновые задачи)

Каждый вызов job получает свой request-scoped контейнер с изолированным EntityManager:

```typescript
jobs: [
  {
    name: "my-sync-job",
    schedule: "0 */1 * * *", // каждый час
    handler: async (container) => {
      const service = container.resolve("myRecordService")
      await service.doSomething()
    },
  },
]
```

При отключении плагина через UI — его cron jobs останавливаются, при включении — возобновляются.

### Страница в админке

Плагин может добавить страницу в клиентский SPA. Создайте React-компонент в `admin/src/client/pages/` и зарегистрируйте роут в `admin/src/client/main.tsx`. Навигация появится автоматически через `adminNav` в определении плагина.

## Контроль доступа

Пользователь может включать/выключать плагины через UI (`/plugins`). При отключении:

- API-роуты с указанными `apiPrefixes` возвращают 403
- Cron jobs останавливаются
- Навигация в сайдбаре скрывается

## Что дальше

В качестве примера смотрите плагин Ozon: `admin/plugins/ozon/`.
